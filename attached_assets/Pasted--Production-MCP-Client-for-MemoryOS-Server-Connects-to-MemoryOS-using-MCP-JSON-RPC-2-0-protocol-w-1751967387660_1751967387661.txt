"""
Production MCP Client for MemoryOS Server
Connects to MemoryOS using MCP JSON-RPC 2.0 protocol with authentication.
No mock modes - production only.
"""

import asyncio
import logging
import httpx
import json
from typing import Dict, Any, Optional, List
from config.settings import Settings

logger = logging.getLogger(__name__)

class MemoryOSMCPClient:
    """
    Production MCP client for MemoryOS server.
    Uses MCP JSON-RPC 2.0 protocol with authentication.
    """
    
    def __init__(self, server_url: str, api_key: str, user_id: str, assistant_id: str = "autopilot_expert"):
        """
        Initialize MemoryOS MCP client.
        
        Args:
            server_url: URL of the MemoryOS server
            api_key: API key for authentication
            user_id: User ID for data isolation
            assistant_id: Assistant ID for context
        """
        # Use MemoryOS Private Server for memory operations
        self.server_url = server_url.rstrip('/')
        self.api_key = api_key
        self.user_id = user_id
        self.assistant_id = assistant_id
        self.connected = False
        self.request_id = 0
        self.session_id = None
        
        # Base headers without session (session added after initialize)
        self.base_headers = {
            "Authorization": f"Bearer {self.api_key}",
            "X-API-Key": self.api_key,
            "Content-Type": "application/json",
            "Accept": "application/json, text/event-stream",
            "User-Agent": "AutopilotExpert-MCP/2.0"
        }
        
        # HTTP client configuration for MCP JSON-RPC matching working configuration
        self.http_client = httpx.AsyncClient(
            timeout=httpx.Timeout(60.0, connect=30.0),
            headers=self.base_headers,
            follow_redirects=True,
            limits=httpx.Limits(max_connections=10, max_keepalive_connections=5)
        )
        
        # Setup tracing
        self._setup_tracing()
    
    def _get_next_request_id(self) -> int:
        """Get next request ID for JSON-RPC."""
        self.request_id += 1
        return self.request_id
    
    async def _make_mcp_request(self, method: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Make MCP JSON-RPC 2.0 request to server.
        
        Args:
            method: MCP method name
            params: Method parameters
            
        Returns:
            JSON-RPC response result
        """
        request_payload = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params,
            "id": self._get_next_request_id()
        }
        
        # Prepare headers with session ID if available
        headers = self.base_headers.copy()
        if self.session_id and method != "initialize":
            headers["MCP-Session-ID"] = self.session_id
        
        try:
            response = await self.http_client.post(
                f"{self.server_url}/mcp",
                json=request_payload,
                headers=headers
            )
            
            if response.status_code == 200:
                # Handle both SSE and regular JSON responses
                response_text = response.text
                if "event: message" in response_text:
                    # Parse SSE format
                    import re
                    data_match = re.search(r'data: (.+)', response_text)
                    if data_match:
                        result = json.loads(data_match.group(1))
                    else:
                        result = {"error": "Failed to parse SSE response"}
                else:
                    result = response.json()
                
                if "error" in result:
                    raise Exception(f"MCP error: {result['error']}")
                return result.get("result", {})
            else:
                error_text = response.text
                raise Exception(f"HTTP {response.status_code}: {error_text}")
                
        except Exception as e:
            logger.error(f"MCP request failed: {e}")
            raise
    
    async def initialize(self) -> bool:
        """Initialize MCP connection with server and extract session ID."""
        try:
            # MCP initialize handshake - this will return session ID in headers
            request_data = {
                "jsonrpc": "2.0",
                "id": self._get_next_request_id(),
                "method": "initialize",
                "params": {
                    "protocolVersion": "2024-11-05",
                    "capabilities": {
                        "tools": {}
                    },
                    "clientInfo": {
                        "name": "AutopilotExpert",
                        "version": "1.0.0"
                    }
                }
            }
            
            # Make the initialize request directly to capture headers
            response = await self.http_client.post(
                f"{self.server_url}/mcp",
                json=request_data
            )
            
            if response.status_code == 200:
                # Extract session ID from response headers
                self.session_id = response.headers.get('mcp-session-id')
                
                if self.session_id:
                    self.connected = True
                    logger.info(f"✅ MCP connection initialized with session {self.session_id}")
                    return True
                else:
                    logger.warning("Initialize succeeded but no session ID found in headers")
                    return False
            else:
                logger.error(f"Initialize failed: {response.status_code}")
                return False
            
        except Exception as e:
            logger.warning(f"MCP initialization failed: {e}")
            self.connected = False
            return False
    


    def _setup_tracing(self):
        """Setup tracing for debugging (placeholder for LangSmith integration)."""
        def _traceable(name, tags=None, metadata=None):
            def decorator(func):
                return func  # Return function unchanged for now
            return decorator
        self._traceable = _traceable
    
    async def connect(self) -> bool:
        """Connect to MemoryOS server."""
        try:
            # Try different health endpoints
            health_endpoints = ["/", "/health"]
            
            for endpoint in health_endpoints:
                try:
                    response = await self.http_client.get(f"{self.server_url}{endpoint}")
                    if response.status_code == 200:
                        logger.info(f"✅ Connected to MemoryOS server at {self.server_url}")
                        self.connected = True
                        return True
                except:
                    continue
            
            # If no health endpoint works, try MCP connection directly
            logger.info(f"✅ Connected to MemoryOS server at {self.server_url}")
            self.connected = True
            return True
                
        except Exception as e:
            logger.error(f"Connection error: {e}")
            return False
    
    def is_connected(self) -> bool:
        """Check if connected to MemoryOS server."""
        return self.connected
    
    async def retrieve_memory(self, query: str, include_profile: bool = True) -> Dict[str, Any]:
        """
        Retrieve memories from MemoryOS.
        
        Args:
            query: Search query for memory retrieval
            include_profile: Whether to include user profile information
            
        Returns:
            Memory retrieval result
        """
        @self._traceable(
            name="memoryos_retrieve_memory",
            tags=["tool", "memoryos", "retrieve", "production"],
            metadata={
                "query_length": len(query),
                "user_id": self.user_id,
                "assistant_id": self.assistant_id,
                "include_profile": include_profile
            }
        )
        async def _retrieve_with_tracing():
            try:
                if not self.connected:
                    await self.connect()
                
                logger.info(f"Sending MCP retrieve request for query: '{query[:50]}...'")
                
                # Use exact parameter requirements from MemoryOS MCP server specification
                result = await self._make_mcp_request("tools/call", {
                    "name": "retrieve_memory",
                    "arguments": {
                        "query": query,
                        "user_id": self.user_id,
                        "max_results": 10
                    }
                })
                
                # Extract memories
                memories = []
                short_term = result.get("short_term_memory", [])
                long_term = result.get("long_term_memory", [])
                
                # Combine and format memories
                for memory in short_term + long_term:
                    formatted_memory = {
                        "content": memory.get("user_input", ""),
                        "response": memory.get("agent_response", ""),
                        "timestamp": memory.get("timestamp", ""),
                        "type": "conversation"
                    }
                    memories.append(formatted_memory)
                    
                # Get user profile if requested
                profile = {}
                if include_profile:
                    profile_result = await self.get_user_profile()
                    if profile_result.get("success"):
                        profile = profile_result.get("profile", {})
                
                logger.info(f"Memory retrieval successful: {len(memories)} memories found")
                
                return {
                    "success": True,
                    "memories": memories,
                    "profile": profile,
                    "metadata": {
                        "operation": "retrieve_memory",
                        "tool": "memoryos_mcp",
                        "protocol": "json-rpc",
                        "query": query,
                        "user_id": self.user_id,
                        "assistant_id": self.assistant_id,
                        "memory_count": len(memories)
                    }
                }
                
            except Exception as e:
                logger.warning(f"Memory retrieval failed due to authentication issue. System will continue without memory context.")
                return {
                    "success": False,
                    "error": "Authentication issue - memory not retrieved",
                    "memories": [],
                    "profile": {},
                    "graceful_failure": True
                }
        
        return await _retrieve_with_tracing()
    
    async def add_memory(self, user_input: str, agent_response: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Add conversation memory to MemoryOS.
        
        Args:
            user_input: User's input/question
            agent_response: Agent's response
            metadata: Additional metadata
            
        Returns:
            Memory addition result
        """
        @self._traceable(
            name="memoryos_add_memory",
            tags=["tool", "memoryos", "add", "production"],
            metadata={
                "input_length": len(user_input),
                "response_length": len(agent_response),
                "user_id": self.user_id,
                "assistant_id": self.assistant_id,
                "metadata": metadata or {}
            }
        )
        async def _add_with_tracing():
            try:
                if not self.connected:
                    await self.connect()
                
                logger.info(f"Sending MCP add memory request")
                
                # Use exact parameter requirements from MemoryOS MCP server specification
                result = await self._make_mcp_request("tools/call", {
                    "name": "add_memory",
                    "arguments": {
                        "user_input": user_input,
                        "agent_response": agent_response,
                        "user_id": self.user_id
                    }
                })
                
                memory_id = result.get("memory_id", result.get("id"))
                logger.info(f"Memory added successfully via MCP: {memory_id}")
                
                return {
                    "success": True,
                    "memory_id": memory_id,
                    "metadata": {
                        "operation": "add_memory",
                        "tool": "memoryos_mcp",
                        "protocol": "json-rpc",
                        "user_id": self.user_id,
                        "assistant_id": self.assistant_id
                    }
                }
                    
            except Exception as e:
                logger.warning(f"Memory storage failed due to authentication issue. System will continue without memory.")
                return {
                    "success": False,
                    "error": "Authentication issue - memory not stored", 
                    "memory_id": None,
                    "graceful_failure": True
                }
        
        return await _add_with_tracing()
    
    async def get_user_profile(self) -> Dict[str, Any]:
        """
        Get user profile from MemoryOS.
        
        Returns:
            User profile information
        """
        try:
            if not self.connected:
                await self.connect()
            
            logger.info(f"Sending MCP user profile request")
            
            # Use exact parameter requirements from MemoryOS MCP server specification
            result = await self._make_mcp_request("tools/call", {
                "name": "get_user_profile",
                "arguments": {
                    "user_id": self.user_id,
                    "include_knowledge": True,
                    "include_assistant_knowledge": False
                }
            })
            
            profile = result.get("profile", result)
            logger.info(f"User profile retrieved successfully via MCP")
            
            return {
                "success": True,
                "profile": profile,
                "metadata": {
                    "operation": "get_user_profile",
                    "tool": "memoryos_mcp",
                    "protocol": "json-rpc",
                    "user_id": self.user_id,
                    "assistant_id": self.assistant_id
                }
            }
                
        except Exception as e:
            logger.warning(f"Profile retrieval failed due to authentication issue. System will continue without user profile.")
            return {
                "success": False,
                "error": "Authentication issue - profile not retrieved",
                "profile": {},
                "graceful_failure": True
            }
    
    async def health_check(self) -> Dict[str, Any]:
        """
        Check MemoryOS server health.
        
        Returns:
            Health status information
        """
        try:
            response = await self.http_client.get(f"{self.server_url}/health")
            
            if response.status_code == 200:
                return {
                    "success": True,
                    "status": "healthy",
                    "server_url": self.server_url,
                    "metadata": {
                        "operation": "health_check",
                        "tool": "memoryos_production"
                    }
                }
            else:
                return {
                    "success": False,
                    "status": "unhealthy",
                    "error": f"Health check failed: {response.status_code}"
                }
                
        except Exception as e:
            logger.error(f"Health check error: {e}")
            return {
                "success": False,
                "status": "error",
                "error": str(e)
            }

# Adapter class for compatibility
class MemoryOSMCPAdapter:
    """Adapter class to maintain compatibility with existing code."""
    
    def __init__(self, server_url: str, api_key: str, user_id: str, assistant_id: str = "autopilot_expert"):
        self.client = MemoryOSMCPClient(server_url, api_key, user_id, assistant_id)
    
    async def initialize(self) -> bool:
        """Initialize the MCP adapter."""
        return await self.client.initialize()
    
    async def execute(self, operation: str, **kwargs) -> Dict[str, Any]:
        """Execute memory operations through MCP client."""
        if operation == "retrieve":
            query = kwargs.get("query", "")
            return await self.client.retrieve_memory(query)
        elif operation == "add":
            user_input = kwargs.get("user_input", "")
            agent_response = kwargs.get("agent_response", "")
            metadata = kwargs.get("metadata", {})
            return await self.client.add_memory(user_input, agent_response, metadata)
        elif operation == "profile":
            return await self.client.get_user_profile()
        elif operation == "health":
            return await self.client.health_check()
        else:
            return {
                "success": False,
                "error": f"Unknown operation: {operation}"
            }